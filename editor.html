<!DOCTYPE html>
<html>
<head>
  <title>Tagged Interval Tree Editor</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      max-width: 800px;
      margin: 0 auto;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    textarea {
      width: 100%;
      height: 200px;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .toolbar {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    button {
      padding: 8px 15px;
      cursor: pointer;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-weight: bold;
    }
    button:hover {
      background-color: #e0e0e0;
    }
    button.active {
      background-color: #c0c0c0;
    }
    #preview {
      border: 1px solid #ccc;
      padding: 15px;
      min-height: 100px;
      border-radius: 4px;
    }
    .debug {
      margin-top: 20px;
      padding: 10px;
      background-color: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 14px;
      max-height: 300px;
      overflow-y: auto;
    }
    .mode-switch {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
      margin-right: 10px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #f77;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .mode-label {
      font-weight: bold;
    }
    .status {
      margin-top: 10px;
      padding: 8px;
      border-radius: 4px;
      background-color: #f0f0f0;
      display: none;
    }
    .status.active {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Tagged Interval Tree Editor</h1>
    
    <div class="mode-switch">
      <label class="toggle-switch">
        <input type="checkbox" id="modeToggle">
        <span class="slider"></span>
      </label>
      <span class="mode-label">Mode: <span id="currentMode">Adding</span></span>
    </div>
    
    <div>
      <div class="toolbar">
        <button id="boldBtn" title="Bold"><b>B</b></button>
        <button id="italicBtn" title="Italic"><i>I</i></button>
        <button id="underlineBtn" title="Underline"><u>U</u></button>
      </div>
      <textarea id="editor">Try selecting some text and applying formatting using the buttons above! You can toggle between Add and Remove mode using the switch.</textarea>
      <div id="status" class="status"></div>
    </div>
    
    <div>
      <h3>Preview:</h3>
      <div id="preview"></div>
    </div>
    
    <div>
      <h3>Tree Structure:</h3>
      <div id="treeDebug" class="debug"></div>
    </div>
  </div>
  
	

  <script>
    // Tagged Interval Tree Implementation
    class IntervalNode {
      constructor(start, end, tag = null) {
        this.interval = [start, end];
        this.tag = tag;
        this.children = [];
      }
      
      toString(indent = 0) {
        const indentStr = ' '.repeat(indent);
        let result = `${indentStr}[${this.interval[0]},${this.interval[1]}]`;
        if (this.tag) {
          result += ` tag: ${this.tag}`;
        }
        result += '\n';
        
        for (const child of this.children) {
          result += child.toString(indent + 2);
        }
        return result;
      }
    }

    class TaggedIntervalTree {
      constructor(start = 0, end = 0) {
        this.root = new IntervalNode(start, end);
      }
      
      // Add a tag to an interval
      addTag(tag, interval) {
        const [start, end] = interval;
        if (start >= end) return; // Invalid interval
        
        console.log(`Adding tag ${tag} to interval [${start},${end}]`);
        this._addTagDFS(this.root, tag, start, end);
        this._ensureTreeProperties(this.root);
      }
      
      _addTagDFS(node, tag, start, end) {
        // Make sure we're working within the node's interval
        start = Math.max(start, node.interval[0]);
        end = Math.min(end, node.interval[1]);
        
        if (start >= end) return null; // No valid interval
        
        // If this node has the same tag, we don't need to add it again
        if (node.tag === tag) return null;
        
        // If no children, create a new child with this tag
        if (node.children.length === 0) {
          const newNode = new IntervalNode(start, end, tag);
          node.children.push(newNode);
          return;
        }
        
        // We need to find where to insert the new tag
        let insertPoints = [];
        let currentPos = start;
        
        // Check if we need to insert before the first child
        if (currentPos < node.children[0].interval[0]) {
          insertPoints.push({
            index: 0,
            start: currentPos,
            end: Math.min(end, node.children[0].interval[0])
          });
          currentPos = Math.min(end, node.children[0].interval[0]);
        }
        
        // Go through each child
        for (let i = 0; i < node.children.length && currentPos < end; i++) {
          const child = node.children[i];
          
          // If current position is before this child's start
          if (currentPos < child.interval[0]) {
            // Insert a new node before this child
            insertPoints.push({
              index: i,
              start: currentPos,
              end: Math.min(end, child.interval[0])
            });
            currentPos = Math.min(end, child.interval[0]);
          }
          
          // If current position overlaps with this child
          if (currentPos < child.interval[1]) {
            // Recursively add tag to this child
            this._addTagDFS(child, tag, currentPos, end);
            currentPos = child.interval[1];
          }
          
          // If there's a gap after this child and before the next
          const nextChild = node.children[i + 1];
          if (currentPos < end && nextChild && currentPos < nextChild.interval[0]) {
            insertPoints.push({
              index: i + 1,
              start: currentPos,
              end: Math.min(end, nextChild.interval[0])
            });
            currentPos = Math.min(end, nextChild.interval[0]);
          }
        }
        
        // If we still have interval left after all children
        if (currentPos < end) {
          insertPoints.push({
            index: node.children.length,
            start: currentPos,
            end: end
          });
        }
        
        // Insert all the new nodes (in reverse order to not mess up indices)
        for (let i = insertPoints.length - 1; i >= 0; i--) {
          const point = insertPoints[i];
          const newNode = new IntervalNode(point.start, point.end, tag);
          node.children.splice(point.index, 0, newNode);
        }
      }
      
      // Remove a tag from an interval
      removeTag(tag, interval) {
        const [start, end] = interval;
        if (start >= end) return false; // Invalid interval
        
        console.log(`Removing tag ${tag} from interval [${start},${end}]`);
        const result = this._removeTagDFS(this.root, tag, start, end);
        this._ensureTreeProperties(this.root);
        return result.removed;
      }
      
      _removeTagDFS(node, tag, start, end) {
        // Adjust interval to node boundaries
        const effectiveStart = Math.max(start, node.interval[0]);
        const effectiveEnd = Math.min(end, node.interval[1]);
        
        if (effectiveStart >= effectiveEnd) {
          return { 
            removed: false,
            state: 'NO_OVERLAP',
            remainingInterval: [start, end],
            rehookNodeList: []
          };
        }
        
        // Check if this node has the tag to remove
        if (node.tag === tag) {
          const originalStart = node.interval[0];
          const originalEnd = node.interval[1];
          const rehookNodeList = [];
          
          // Case 1: Remove-interval is inside a tag (not touching start and end position)
          if (effectiveStart > originalStart && effectiveEnd < originalEnd) {
            // Nodes inside remove-interval
            const insideNodes = [];
            // Nodes before remove-interval
            const beforeNodes = [];
            // Nodes after remove-interval
            const afterNodes = [];
            
            // Categorize children
            for (const child of node.children) {
              if (child.interval[1] <= effectiveStart) {
                // Child is entirely before the remove interval
                beforeNodes.push(child);
              } else if (child.interval[0] >= effectiveEnd) {
                // Child is entirely after the remove interval
                afterNodes.push(child);
              } else {
                // Child overlaps with remove interval - needs recursive handling
                const childResult = this._removeTagDFS(child, tag, start, end);
                if (childResult.removed) {
                  // Add any rehook nodes to our list
                  rehookNodeList.push(...childResult.rehookNodeList);
                } else {
                  // If nothing was removed, treat it as inside
                  insideNodes.push(child);
                }
              }
            }
            
            // Create pre-tag node
            if (effectiveStart > originalStart) {
              const preTagNode = new IntervalNode(originalStart, effectiveStart, tag);
              preTagNode.children = beforeNodes;
              rehookNodeList.push(preTagNode);
            } else {
              // Just add before nodes directly to rehook list
              rehookNodeList.push(...beforeNodes);
            }
            
            // Add inside nodes directly to rehook list
            rehookNodeList.push(...insideNodes);
            
            // Create post-tag node
            if (effectiveEnd < originalEnd) {
              const postTagNode = new IntervalNode(effectiveEnd, originalEnd, tag);
              postTagNode.children = afterNodes;
              rehookNodeList.push(postTagNode);
            } else {
              // Just add after nodes directly to rehook list
              rehookNodeList.push(...afterNodes);
            }
            
            return {
              removed: true,
              state: 'REMOVE-INTERVAL-INSIDE',
              remainingInterval: [effectiveEnd, end], // This will be ignored by parent
              rehookNodeList: rehookNodeList
            };
          }
          
          // Case 2: Remove-interval is at start of tag interval
          if (effectiveStart <= originalStart && effectiveEnd < originalEnd) {
            // Adjust this node's interval
            node.interval[0] = effectiveEnd;
            
            return {
              removed: true, 
              state: 'REMOVE-INTERVAL-LEFT',
              remainingInterval: [effectiveEnd, end],
              rehookNodeList: []
            };
          }
          
          // Case 3: Remove-interval is at end of tag interval
          if (effectiveStart > originalStart && effectiveEnd >= originalEnd) {
            // Adjust this node's interval
            node.interval[1] = effectiveStart;
            
            return {
              removed: true,
              state: 'REMOVE-INTERVAL-RIGHT',
              remainingInterval: [start, effectiveStart],
              rehookNodeList: []
            };
          }
          
          // Case 4: Remove-interval covers entire tag
          if (effectiveStart <= originalStart && effectiveEnd >= originalEnd) {
            return {
              removed: true,
              state: 'REMOVE-ENTIRE-NODE',
              remainingInterval: [effectiveEnd, end],
              rehookNodeList: node.children
            };
          }
        }
        
        // Process children
        let removed = false;
        let i = 0;
        
        while (i < node.children.length) {
          const child = node.children[i];
          
          // Skip if no overlap
          if (effectiveEnd <= child.interval[0] || effectiveStart >= child.interval[1]) {
            i++;
            continue;
          }
          
          const childResult = this._removeTagDFS(child, tag, start, end);
          
          if (childResult.removed) {
            removed = true;
            
            if (childResult.state === 'REMOVE-ENTIRE-NODE' || 
                childResult.state === 'REMOVE-INTERVAL-INSIDE') {
              // Remove this child and add its rehook nodes
              node.children.splice(i, 1);
              
              // Insert rehook nodes
              if (childResult.rehookNodeList.length > 0) {
                Array.prototype.splice.apply(
                  node.children, 
                  [i, 0].concat(childResult.rehookNodeList)
                );
                i += childResult.rehookNodeList.length;
              }
            } else {
              // For LEFT and RIGHT states, the child was adjusted, so keep it
              i++;
            }
            
            // Continue with remaining interval if any
            if (childResult.remainingInterval[0] < childResult.remainingInterval[1]) {
              // Call recursively with remaining interval
              const remainingResult = this._removeTagDFS(
                node, 
                tag, 
                childResult.remainingInterval[0], 
                childResult.remainingInterval[1]
              );
              
              if (remainingResult.removed) {
                removed = true;
              }
            }
          } else {
            i++;
          }
        }
        
        return {
          removed: removed,
          state: 'PROCESSED_CHILDREN',
          remainingInterval: [end, end], // Empty interval
          rehookNodeList: []
        };
      }
      
      // Ensure tree properties (non-overlapping, sorted, merged, inside parent)
      _ensureTreeProperties(node) {
        if (!node || node.children.length === 0) return;
        
        // Sort children by start position (Sorted property)
        node.children.sort((a, b) => a.interval[0] - b.interval[0]);
        
        // Remove any empty intervals
        node.children = node.children.filter(child => 
          child.interval[0] < child.interval[1]);
        
        if (node.children.length === 0) return;
        
        // Merge adjacent/overlapping nodes with same tag (Merged property)
        const mergedChildren = [];
        let current = node.children[0];
        
        for (let i = 1; i < node.children.length; i++) {
          const next = node.children[i];
          
          // Same tag and adjacent/overlapping - merge
          if (current.tag === next.tag && next.interval[0] <= current.interval[1]) {
            current.interval[1] = Math.max(current.interval[1], next.interval[1]);
            // Merge children too
            current.children.push(...next.children);
          } else {
            mergedChildren.push(current);
            current = next;
          }
        }
        
        mergedChildren.push(current);
        node.children = mergedChildren;
        
        // Process children recursively
        for (const child of node.children) {
          // Ensure child interval fits within parent (Inside property)
          child.interval[0] = Math.max(child.interval[0], node.interval[0]);
          child.interval[1] = Math.min(child.interval[1], node.interval[1]);
          
          // Check Tag property (a node cannot have the same tag as its parent)
          if (child.tag === node.tag) {
            // Move child's children up and remove child
            for (const grandchild of child.children) {
              if (grandchild.tag !== node.tag) {
                node.children.push(grandchild);
              }
            }
            // Remove this child from the list later
          } else {
            // Process this child recursively
            this._ensureTreeProperties(child);
          }
        }
        
        // Final filter to remove children with same tag as parent
        node.children = node.children.filter(child => child.tag !== node.tag);
        
        // One more sort to ensure everything is properly ordered
        node.children.sort((a, b) => a.interval[0] - b.interval[0]);
      }
      
      // Check if an interval has a specific tag
      hasTag(tag, interval) {
        const [start, end] = interval;
        return this._checkTagDFS(this.root, tag, start, end);
      }
      
      _checkTagDFS(node, tag, start, end) {
        // If this node has the tag and fully contains the interval
        if (node.tag === tag && 
            node.interval[0] <= start && 
            node.interval[1] >= end) {
          return true;
        }
        
        // Check children
        for (const child of node.children) {
          // Skip if no overlap
          if (end <= child.interval[0] || start >= child.interval[1]) {
            continue;
          }
          
          if (this._checkTagDFS(child, tag, start, end)) {
            return true;
          }
        }
        
        return false;
      }
      
      // Get formatted text
      getFormattedText(text) {
        // Collect all formatting tags at each position
        const markers = [];
        
        function collectMarkers(node, parentTags = []) {
          if (node.tag) {
            // Add opening tag
            markers.push({
              position: node.interval[0],
              tag: node.tag,
              isOpening: true
            });
            
            // Add closing tag
            markers.push({
              position: node.interval[1],
              tag: node.tag,
              isOpening: false
            });
          }
          
          // Process children
          for (const child of node.children) {
            collectMarkers(child, node.tag ? [...parentTags, node.tag] : parentTags);
          }
        }
        
        collectMarkers(this.root);
        
        // Sort markers by position (closing tags come before opening tags at same position)
        markers.sort((a, b) => {
          if (a.position === b.position) {
            return a.isOpening ? 1 : -1;
          }
          return a.position - b.position;
        });
        
        // Insert tags into text
        let result = '';
        let lastPosition = 0;
        
        for (const marker of markers) {
          // Add text up to this marker
          result += text.substring(lastPosition, marker.position);
          lastPosition = marker.position;
          
          // Add tag
          if (marker.isOpening) {
            result += `<${marker.tag}>`;
          } else {
            result += `</${marker.tag}>`;
          }
        }
        
        // Add remaining text
        result += text.substring(lastPosition);
        
        return result;
      }
      
      toString() {
        return this.root.toString();
      }
    }

    // UI Integration
    const editor = document.getElementById('editor');
    const preview = document.getElementById('preview');
    const treeDebug = document.getElementById('treeDebug');
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    const underlineBtn = document.getElementById('underlineBtn');
    const modeToggle = document.getElementById('modeToggle');
    const currentMode = document.getElementById('currentMode');
    const status = document.getElementById('status');
    
    // Initialize tree
    let tree = new TaggedIntervalTree(0, editor.value.length);
    
    // Initial mode is "add"
    let isRemoveMode = false;
    
    function updatePreview() {
      const text = editor.value;
      // Update preview with formatted text
      preview.innerHTML = tree.getFormattedText(text);
      treeDebug.textContent = tree.toString();
    }
    
    function showStatus(message, isError = false) {
      status.textContent = message;
      status.classList.add('active');
      status.style.backgroundColor = isError ? '#ffe0e0' : '#e0ffe0';
      setTimeout(() => {
        status.classList.remove('active');
      }, 3000);
    }
    
    function toggleTag(tag) {
      const start = editor.selectionStart;
      const end = editor.selectionEnd;
      
      if (start === end) {
        showStatus("Please select some text first!", true);
        return;
      }
      
      if (isRemoveMode) {
        const removed = tree.removeTag(tag, [start, end]);
        if (removed) {
          showStatus(`Removed ${tag} formatting from selection`);
        } else {
          showStatus(`No ${tag} formatting found in selection`, true);
        }
      } else {
        tree.addTag(tag, [start, end]);
        showStatus(`Applied ${tag} formatting to selection`);
      }
      
      updatePreview();
    }
    
    // Initialize with empty tree
    tree = new TaggedIntervalTree(0, editor.value.length);
    updatePreview();
    
    // Event listeners
    editor.addEventListener('input', function() {
      // Resize the tree if needed
      if (editor.value.length > tree.root.interval[1]) {
        tree.root.interval[1] = editor.value.length;
      }
      updatePreview();
    });
    
    // Mode toggle
    modeToggle.addEventListener('change', function() {
      isRemoveMode = this.checked;
      currentMode.textContent = isRemoveMode ? "Removing" : "Adding";
      currentMode.style.color = isRemoveMode ? "#f00" : "#000";
      showStatus(`Switched to ${isRemoveMode ? 'Remove' : 'Add'} mode`);
    });
    
    // Format buttons
    boldBtn.addEventListener('click', function() {
      toggleTag('b');
    });
    
    italicBtn.addEventListener('click', function() {
      toggleTag('i');
    });
    
    underlineBtn.addEventListener('click', function() {
      toggleTag('u');
    });
  </script>
</body>
</html>
